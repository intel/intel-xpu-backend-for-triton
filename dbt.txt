anthony-test/bload.ttgir:12:18: error: Number of elements must be power-of-two, but %6 = "tt.load"(%5) <{boundaryCheck = array<i32: 0, 1>, cache = 1 : i32, evict = 1 : i32, isVolatile = false, operandSegmentSizes = array<i32: 1, 0, 0>}> {ttig.block_io = "row_major"} : (!tt.ptr<tensor<31x31xf32, #ttg.dot_op<{opIdx = 0, parent = #ttig.dpas<{repeatCount = 8, systolicDepth = 8, executionSize = 16, opsPerChan = 1, threadsPerWarp = 16, warpsPerCTA = [8, 4], repCluster = [4, 2], A = [32, 8], B = [8, 32], C = [32, 32]}>, kWidth = 1}>>>) -> tensor<31x31xf32, #ttg.dot_op<{opIdx = 0, parent = #ttig.dpas<{repeatCount = 8, systolicDepth = 8, executionSize = 16, opsPerChan = 1, threadsPerWarp = 16, warpsPerCTA = [8, 4], repCluster = [4, 2], A = [32, 8], B = [8, 32], C = [32, 32]}>, kWidth = 1}>> doesn't follow the rule (961) elements
            %2 = tt.load %1 {boundaryCheck = array<i32: 0, 1>, ttig.block_io = "row_major"} : !tt.ptr<tensor<31x31xf32, #ttg.dot_op<{opIdx = 0, parent = #mma, kWidth = 1}>>>
                 ^
anthony-test/bload.ttgir:12:18: note: see current operation: %6 = "tt.load"(%5) <{boundaryCheck = array<i32: 0, 1>, cache = 1 : i32, evict = 1 : i32, isVolatile = false, operandSegmentSizes = array<i32: 1, 0, 0>}> {ttig.block_io = "row_major"} : (!tt.ptr<tensor<31x31xf32, #ttg.dot_op<{opIdx = 0, parent = #ttig.dpas<{repeatCount = 8, systolicDepth = 8, executionSize = 16, opsPerChan = 1, threadsPerWarp = 16, warpsPerCTA = [8, 4], repCluster = [4, 2], A = [32, 8], B = [8, 32], C = [32, 32]}>, kWidth = 1}>>>) -> tensor<31x31xf32, #ttg.dot_op<{opIdx = 0, parent = #ttig.dpas<{repeatCount = 8, systolicDepth = 8, executionSize = 16, opsPerChan = 1, threadsPerWarp = 16, warpsPerCTA = [8, 4], repCluster = [4, 2], A = [32, 8], B = [8, 32], C = [32, 32]}>, kWidth = 1}>>
