// -----// IR Dump Before Inliner (inline) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc14 = loc("x_ptr"(#loc))
#loc15 = loc("y_ptr"(#loc))
#loc16 = loc("output_ptr"(#loc))
#loc17 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %pid = tt.get_program_id x : i32 loc(#loc18)
    %block_start = arith.constant 1024 : i32 loc(#loc19)
    %block_start_0 = arith.constant 1024 : i32 loc(#loc19)
    %block_start_1 = arith.muli %pid, %block_start_0 : i32 loc(#loc19)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc20)
    %offsets_2 = tt.splat %block_start_1 : i32 -> tensor<1024xi32> loc(#loc21)
    %offsets_3 = arith.addi %offsets_2, %offsets : tensor<1024xi32> loc(#loc21)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc22)
    %mask_4 = arith.cmpi slt, %offsets_3, %mask : tensor<1024xi32> loc(#loc22)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc23)
    %x_5 = tt.addptr %x, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc23)
    %x_6 = tt.load %x_5, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y_7 = tt.addptr %y, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc25)
    %y_8 = tt.load %y_7, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %output = arith.addf %x_6, %y_8 : tensor<1024xf32> loc(#loc27)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc11)
    %1 = tt.addptr %0, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc11)
    tt.store %1, %output, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc12)
    tt.return loc(#loc13)
  } loc(#loc)
} loc(#loc)
#loc1 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc18 = loc("pid"(#loc1))
#loc19 = loc("block_start"(#loc2))
#loc20 = loc("offsets"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("mask"(#loc5))
#loc23 = loc("x"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("y"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("output"(#loc10))


// -----// IR Dump Before Canonicalizer (canonicalize) ('tt.func' operation: @add_kernel) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc14 = loc("x_ptr"(#loc))
#loc15 = loc("y_ptr"(#loc))
#loc16 = loc("output_ptr"(#loc))
#loc17 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %pid = tt.get_program_id x : i32 loc(#loc18)
    %block_start = arith.constant 1024 : i32 loc(#loc19)
    %block_start_0 = arith.constant 1024 : i32 loc(#loc19)
    %block_start_1 = arith.muli %pid, %block_start_0 : i32 loc(#loc19)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc20)
    %offsets_2 = tt.splat %block_start_1 : i32 -> tensor<1024xi32> loc(#loc21)
    %offsets_3 = arith.addi %offsets_2, %offsets : tensor<1024xi32> loc(#loc21)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc22)
    %mask_4 = arith.cmpi slt, %offsets_3, %mask : tensor<1024xi32> loc(#loc22)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc23)
    %x_5 = tt.addptr %x, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc23)
    %x_6 = tt.load %x_5, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y_7 = tt.addptr %y, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc25)
    %y_8 = tt.load %y_7, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %output = arith.addf %x_6, %y_8 : tensor<1024xf32> loc(#loc27)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc11)
    %1 = tt.addptr %0, %offsets_3 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc11)
    tt.store %1, %output, %mask_4 : tensor<1024x!tt.ptr<f32>> loc(#loc12)
    tt.return loc(#loc13)
  } loc(#loc)
} loc(#loc)
#loc1 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc18 = loc("pid"(#loc1))
#loc19 = loc("block_start"(#loc2))
#loc20 = loc("offsets"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("mask"(#loc5))
#loc23 = loc("x"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("y"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("output"(#loc10))


// -----// IR Dump Before TritonIntelTensorDescToBlockPointer (triton-intel-tdesc-to-block-pointer) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonRewriteTensorDescriptorToPointer (triton-rewrite-tensor-descriptor-to-pointer) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before LoopInvariantCodeMotion (loop-invariant-code-motion) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelRemoveBoundaryChecks (triton-intel-remove-boundary-checks) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelRemoveMasks (triton-intel-remove-masks) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelStrideVersioning (triton-intel-stride-versioning) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelFuseReshape (triton-intel-fuse-reshape) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonCombineOps (triton-combine) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonReorderBroadcast (triton-reorder-broadcast) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonLoopUnroll (triton-loop-unroll) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonAnnotateModule (triton-annotate-module) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before ConvertTritonToTritonGPU (convert-triton-to-tritongpu) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>>, tensor<1024xi32> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUCoalesce (tritonintelgpu-coalesce) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPURemoveLayoutConversions (tritonintelgpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [1], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#blocked1 = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = ttg.convert_layout %x_3 : tensor<1024x!tt.ptr<f32>, #blocked> -> tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc25)
    %x_5 = ttg.convert_layout %mask_2 : tensor<1024xi1, #blocked> -> tensor<1024xi1, #blocked1> loc(#loc25)
    %x_6 = tt.load %x_4, %x_5 : tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc25)
    %x_7 = ttg.convert_layout %x_6 : tensor<1024xf32, #blocked1> -> tensor<1024xf32, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_8 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_9 = ttg.convert_layout %y_8 : tensor<1024x!tt.ptr<f32>, #blocked> -> tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc27)
    %y_10 = ttg.convert_layout %mask_2 : tensor<1024xi1, #blocked> -> tensor<1024xi1, #blocked1> loc(#loc27)
    %y_11 = tt.load %y_9, %y_10 : tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc27)
    %y_12 = ttg.convert_layout %y_11 : tensor<1024xf32, #blocked1> -> tensor<1024xf32, #blocked> loc(#loc27)
    %output = arith.addf %x_7, %y_12 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    %2 = ttg.convert_layout %1 : tensor<1024x!tt.ptr<f32>, #blocked> -> tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc13)
    %3 = ttg.convert_layout %output : tensor<1024xf32, #blocked> -> tensor<1024xf32, #blocked1> loc(#loc13)
    %4 = ttg.convert_layout %mask_2 : tensor<1024xi1, #blocked> -> tensor<1024xi1, #blocked1> loc(#loc13)
    tt.store %2, %3, %4 : tensor<1024x!tt.ptr<f32>, #blocked1> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUAccelerateMatmul (tritonintelgpu-accelerate-matmul) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUMaterializeBlockPointer (tritonintelgpu-materialize-block-pointer) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPURemoveLayoutConversions (tritonintelgpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUOptimizeDotOperands (tritonintelgpu-optimize-dot-operands) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUPipeline (tritonintelgpu-pipeline) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUReduceVariableLiveness (tritonintelgpu-reduce-variable-liveness) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUFuseNestedLoops (tritongpu-fuse-nested-loops) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonLoopInvariantCodeMotion (triton-licm) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUCombineTensorSelectAndIf (tritongpu-combine-tensor-select-and-if) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUOptimizeThreadLocality (tritongpu-optimize-thread-locality) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUPrefetch (tritongpu-prefetch) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUOptimizeDotOperands (tritongpu-optimize-dot-operands) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPURemoveLayoutConversions (tritonintelgpu-remove-layout-conversions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPUReduceDataDuplication (tritonintelgpu-reduce-data-duplication) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUReorderInstructions (tritongpu-reorder-instructions) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before SCCP (sccp) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before ArithEmulateUnsupportedFloats (arith-emulate-unsupported-floats) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before SCFToControlFlowPass (convert-scf-to-cf) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before GluonInline (gluon-inline) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before ConvertIndexToLLVMPass (convert-index-to-llvm) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before IntelAllocateSharedMemory (intel-allocate-shared-memory) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonGPUGlobalScratchAllocationPass (tritongpu-global-scratch-memory-allocation) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {"ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before ConvertTritonIntelGPUToLLVM (convert-triton-intel-gpu-to-llvm) ('builtin.module' operation) //----- //
#blocked = #ttg.blocked<{sizePerThread = [4], threadsPerWarp = [32], warpsPerCTA = [4], order = [0]}>
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  tt.func public @add_kernel(%x_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("x_ptr"(#loc)), %y_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("y_ptr"(#loc)), %output_ptr: !tt.ptr<f32> {tt.divisibility = 16 : i32} loc("output_ptr"(#loc)), %n_elements: i32 {tt.divisibility = 16 : i32} loc("n_elements"(#loc))) attributes {noinline = false, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %c1024_i32 = arith.constant 1024 : i32 loc(#loc1)
    %pid = tt.get_program_id x : i32 loc(#loc19)
    %block_start = arith.muli %pid, %c1024_i32 : i32 loc(#loc20)
    %offsets = tt.make_range {end = 1024 : i32, start = 0 : i32} : tensor<1024xi32, #blocked> loc(#loc21)
    %offsets_0 = tt.splat %block_start : i32 -> tensor<1024xi32, #blocked> loc(#loc22)
    %offsets_1 = arith.addi %offsets_0, %offsets : tensor<1024xi32, #blocked> loc(#loc22)
    %mask = tt.splat %n_elements : i32 -> tensor<1024xi32, #blocked> loc(#loc23)
    %mask_2 = arith.cmpi slt, %offsets_1, %mask : tensor<1024xi32, #blocked> loc(#loc23)
    %x = tt.splat %x_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc24)
    %x_3 = tt.addptr %x, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc24)
    %x_4 = tt.load %x_3, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc25)
    %y = tt.splat %y_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc26)
    %y_5 = tt.addptr %y, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc26)
    %y_6 = tt.load %y_5, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc27)
    %output = arith.addf %x_4, %y_6 : tensor<1024xf32, #blocked> loc(#loc28)
    %0 = tt.splat %output_ptr : !tt.ptr<f32> -> tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc12)
    %1 = tt.addptr %0, %offsets_1 : tensor<1024x!tt.ptr<f32>, #blocked>, tensor<1024xi32, #blocked> loc(#loc12)
    tt.store %1, %output, %mask_2 : tensor<1024x!tt.ptr<f32>, #blocked> loc(#loc13)
    tt.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc25 = loc("x"(#loc8))
#loc26 = loc("y"(#loc9))
#loc27 = loc("y"(#loc10))
#loc28 = loc("output"(#loc11))


Running LoadStoreOpToLLVM pass
Running LoadStoreOpToLLVM pass
// -----// IR Dump Before ConvertTritonGENToLLVM (convert-tritongen-to-llvm) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %output_ptr_0 = builtin.unrealized_conversion_cast %output_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc17)
    %y_ptr_1 = builtin.unrealized_conversion_cast %y_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc16)
    %x_ptr_2 = builtin.unrealized_conversion_cast %x_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc15)
    %0 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.mlir.constant(0 : i32) : i32 loc(#loc19)
    %pid_3 = llvm.call spir_funccc @_Z12get_group_idj(%pid) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %pid_4 = llvm.trunc %pid_3 : i64 to i32 loc(#loc19)
    %block_start = llvm.mul %pid_4, %0 : i32 loc(#loc20)
    %offsets = llvm.mlir.constant(0 : index) : i32 loc(#loc21)
    %offsets_5 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_6 = llvm.call spir_funccc @_Z12get_local_idj(%offsets_5) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc21)
    %offsets_7 = llvm.trunc %offsets_6 : i64 to i32 loc(#loc21)
    %offsets_8 = llvm.mlir.constant(127 : i32) : i32 loc(#loc21)
    %offsets_9 = llvm.and %offsets_7, %offsets_8 : i32 loc(#loc21)
    %offsets_10 = llvm.mlir.constant(32 : i32) : i32 loc(#loc21)
    %offsets_11 = llvm.urem %offsets_9, %offsets_10 : i32 loc(#loc21)
    %offsets_12 = llvm.udiv %offsets_9, %offsets_10 : i32 loc(#loc21)
    %offsets_13 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_14 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_15 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_16 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_17 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_18 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_19 = llvm.shl %offsets_11, %offsets_18 : i32 loc(#loc21)
    %offsets_20 = llvm.or %offsets_17, %offsets_19 : i32 loc(#loc21)
    %offsets_21 = llvm.mlir.constant(5 : i32) : i32 loc(#loc21)
    %offsets_22 = llvm.shl %offsets_12, %offsets_21 : i32 loc(#loc21)
    %offsets_23 = llvm.or %offsets_20, %offsets_22 : i32 loc(#loc21)
    %offsets_24 = llvm.mlir.constant(127 : i32) : i32 loc(#loc21)
    %offsets_25 = llvm.and %offsets_23, %offsets_24 : i32 loc(#loc21)
    %offsets_26 = llvm.mlir.constant(2 : i32) : i32 loc(#loc21)
    %offsets_27 = llvm.shl %offsets_25, %offsets_26 : i32 loc(#loc21)
    %offsets_28 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_29 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_30 = llvm.or disjoint %offsets_27, %offsets_29 : i32 loc(#loc21)
    %offsets_31 = llvm.xor %offsets_16, %offsets_30 : i32 loc(#loc21)
    %offsets_32 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_33 = llvm.xor %offsets_31, %offsets_32 : i32 loc(#loc21)
    %offsets_34 = llvm.mlir.constant(1 : i32) : i32 loc(#loc21)
    %offsets_35 = llvm.xor %offsets_31, %offsets_34 : i32 loc(#loc21)
    %offsets_36 = llvm.mlir.constant(2 : i32) : i32 loc(#loc21)
    %offsets_37 = llvm.xor %offsets_31, %offsets_36 : i32 loc(#loc21)
    %offsets_38 = llvm.mlir.constant(3 : i32) : i32 loc(#loc21)
    %offsets_39 = llvm.xor %offsets_31, %offsets_38 : i32 loc(#loc21)
    %offsets_40 = llvm.mlir.constant(512 : i32) : i32 loc(#loc21)
    %offsets_41 = llvm.xor %offsets_31, %offsets_40 : i32 loc(#loc21)
    %offsets_42 = llvm.mlir.constant(513 : i32) : i32 loc(#loc21)
    %offsets_43 = llvm.xor %offsets_31, %offsets_42 : i32 loc(#loc21)
    %offsets_44 = llvm.mlir.constant(514 : i32) : i32 loc(#loc21)
    %offsets_45 = llvm.xor %offsets_31, %offsets_44 : i32 loc(#loc21)
    %offsets_46 = llvm.mlir.constant(515 : i32) : i32 loc(#loc21)
    %offsets_47 = llvm.xor %offsets_31, %offsets_46 : i32 loc(#loc21)
    %offsets_48 = llvm.add %offsets_33, %offsets : i32 loc(#loc21)
    %offsets_49 = llvm.add %offsets_35, %offsets : i32 loc(#loc21)
    %offsets_50 = llvm.add %offsets_37, %offsets : i32 loc(#loc21)
    %offsets_51 = llvm.add %offsets_39, %offsets : i32 loc(#loc21)
    %offsets_52 = llvm.add %offsets_41, %offsets : i32 loc(#loc21)
    %offsets_53 = llvm.add %offsets_43, %offsets : i32 loc(#loc21)
    %offsets_54 = llvm.add %offsets_45, %offsets : i32 loc(#loc21)
    %offsets_55 = llvm.add %offsets_47, %offsets : i32 loc(#loc21)
    %offsets_56 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc21)
    %offsets_57 = llvm.insertvalue %offsets_48, %offsets_56[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_58 = llvm.insertvalue %offsets_49, %offsets_57[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_59 = llvm.insertvalue %offsets_50, %offsets_58[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_60 = llvm.insertvalue %offsets_51, %offsets_59[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_61 = llvm.insertvalue %offsets_52, %offsets_60[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_62 = llvm.insertvalue %offsets_53, %offsets_61[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_63 = llvm.insertvalue %offsets_54, %offsets_62[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_64 = llvm.insertvalue %offsets_55, %offsets_63[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_65 = llvm.bitcast %block_start : i32 to i32 loc(#loc22)
    %offsets_66 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc22)
    %offsets_67 = llvm.insertvalue %offsets_65, %offsets_66[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_68 = llvm.insertvalue %offsets_65, %offsets_67[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_69 = llvm.insertvalue %offsets_65, %offsets_68[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_70 = llvm.insertvalue %offsets_65, %offsets_69[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_71 = llvm.insertvalue %offsets_65, %offsets_70[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_72 = llvm.insertvalue %offsets_65, %offsets_71[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_73 = llvm.insertvalue %offsets_65, %offsets_72[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_74 = llvm.insertvalue %offsets_65, %offsets_73[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_75 = llvm.extractvalue %offsets_74[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_76 = llvm.extractvalue %offsets_74[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_77 = llvm.extractvalue %offsets_74[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_78 = llvm.extractvalue %offsets_74[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_79 = llvm.extractvalue %offsets_74[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_80 = llvm.extractvalue %offsets_74[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_81 = llvm.extractvalue %offsets_74[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_82 = llvm.extractvalue %offsets_74[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_83 = llvm.extractvalue %offsets_64[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_84 = llvm.extractvalue %offsets_64[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_85 = llvm.extractvalue %offsets_64[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_86 = llvm.extractvalue %offsets_64[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_87 = llvm.extractvalue %offsets_64[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_88 = llvm.extractvalue %offsets_64[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_89 = llvm.extractvalue %offsets_64[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_90 = llvm.extractvalue %offsets_64[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_91 = llvm.add %offsets_75, %offsets_83 : i32 loc(#loc22)
    %offsets_92 = llvm.add %offsets_76, %offsets_84 : i32 loc(#loc22)
    %offsets_93 = llvm.add %offsets_77, %offsets_85 : i32 loc(#loc22)
    %offsets_94 = llvm.add %offsets_78, %offsets_86 : i32 loc(#loc22)
    %offsets_95 = llvm.add %offsets_79, %offsets_87 : i32 loc(#loc22)
    %offsets_96 = llvm.add %offsets_80, %offsets_88 : i32 loc(#loc22)
    %offsets_97 = llvm.add %offsets_81, %offsets_89 : i32 loc(#loc22)
    %offsets_98 = llvm.add %offsets_82, %offsets_90 : i32 loc(#loc22)
    %offsets_99 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc22)
    %offsets_100 = llvm.insertvalue %offsets_91, %offsets_99[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_101 = llvm.insertvalue %offsets_92, %offsets_100[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_102 = llvm.insertvalue %offsets_93, %offsets_101[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_103 = llvm.insertvalue %offsets_94, %offsets_102[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_104 = llvm.insertvalue %offsets_95, %offsets_103[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_105 = llvm.insertvalue %offsets_96, %offsets_104[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_106 = llvm.insertvalue %offsets_97, %offsets_105[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_107 = llvm.insertvalue %offsets_98, %offsets_106[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %mask = llvm.bitcast %n_elements : i32 to i32 loc(#loc23)
    %mask_108 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc23)
    %mask_109 = llvm.insertvalue %mask, %mask_108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_110 = llvm.insertvalue %mask, %mask_109[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_111 = llvm.insertvalue %mask, %mask_110[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_112 = llvm.insertvalue %mask, %mask_111[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_113 = llvm.insertvalue %mask, %mask_112[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_114 = llvm.insertvalue %mask, %mask_113[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_115 = llvm.insertvalue %mask, %mask_114[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_116 = llvm.insertvalue %mask, %mask_115[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_117 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_118 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_119 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_120 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_121 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_122 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_123 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_124 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_125 = llvm.extractvalue %mask_116[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_126 = llvm.extractvalue %mask_116[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_127 = llvm.extractvalue %mask_116[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_128 = llvm.extractvalue %mask_116[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_129 = llvm.extractvalue %mask_116[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_130 = llvm.extractvalue %mask_116[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_131 = llvm.extractvalue %mask_116[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_132 = llvm.extractvalue %mask_116[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_133 = llvm.icmp "slt" %mask_117, %mask_125 : i32 loc(#loc23)
    %mask_134 = llvm.icmp "slt" %mask_118, %mask_126 : i32 loc(#loc23)
    %mask_135 = llvm.icmp "slt" %mask_119, %mask_127 : i32 loc(#loc23)
    %mask_136 = llvm.icmp "slt" %mask_120, %mask_128 : i32 loc(#loc23)
    %mask_137 = llvm.icmp "slt" %mask_121, %mask_129 : i32 loc(#loc23)
    %mask_138 = llvm.icmp "slt" %mask_122, %mask_130 : i32 loc(#loc23)
    %mask_139 = llvm.icmp "slt" %mask_123, %mask_131 : i32 loc(#loc23)
    %mask_140 = llvm.icmp "slt" %mask_124, %mask_132 : i32 loc(#loc23)
    %mask_141 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc23)
    %mask_142 = llvm.insertvalue %mask_133, %mask_141[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_143 = llvm.insertvalue %mask_133, %mask_142[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_144 = llvm.insertvalue %mask_133, %mask_143[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_145 = llvm.insertvalue %mask_133, %mask_144[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_146 = llvm.insertvalue %mask_137, %mask_145[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_147 = llvm.insertvalue %mask_137, %mask_146[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_148 = llvm.insertvalue %mask_137, %mask_147[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_149 = llvm.insertvalue %mask_137, %mask_148[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %x = llvm.bitcast %x_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc24)
    %x_150 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc24)
    %x_151 = llvm.insertvalue %x, %x_150[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_152 = llvm.insertvalue %x, %x_151[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_153 = llvm.insertvalue %x, %x_152[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_154 = llvm.insertvalue %x, %x_153[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_155 = llvm.insertvalue %x, %x_154[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_156 = llvm.insertvalue %x, %x_155[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_157 = llvm.insertvalue %x, %x_156[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_158 = llvm.insertvalue %x, %x_157[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_159 = llvm.extractvalue %x_158[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_160 = llvm.extractvalue %x_158[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_161 = llvm.extractvalue %x_158[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_162 = llvm.extractvalue %x_158[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_163 = llvm.extractvalue %x_158[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_164 = llvm.extractvalue %x_158[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_165 = llvm.extractvalue %x_158[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_166 = llvm.extractvalue %x_158[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_167 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_168 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_169 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_170 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_171 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_172 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_173 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_174 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_175 = llvm.getelementptr %x_159[%x_167] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_176 = llvm.getelementptr %x_160[%x_168] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_177 = llvm.getelementptr %x_161[%x_169] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_178 = llvm.getelementptr %x_162[%x_170] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_179 = llvm.getelementptr %x_163[%x_171] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_180 = llvm.getelementptr %x_164[%x_172] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_181 = llvm.getelementptr %x_165[%x_173] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_182 = llvm.getelementptr %x_166[%x_174] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_183 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc24)
    %x_184 = llvm.insertvalue %x_175, %x_183[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_185 = llvm.insertvalue %x_176, %x_184[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_186 = llvm.insertvalue %x_177, %x_185[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_187 = llvm.insertvalue %x_178, %x_186[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_188 = llvm.insertvalue %x_179, %x_187[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_189 = llvm.insertvalue %x_180, %x_188[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_190 = llvm.insertvalue %x_181, %x_189[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_191 = llvm.insertvalue %x_182, %x_190[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_192 = llvm.extractvalue %x_191[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_193 = llvm.extractvalue %x_191[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_194 = llvm.extractvalue %x_191[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_195 = llvm.extractvalue %x_191[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_196 = llvm.extractvalue %x_191[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_197 = llvm.extractvalue %x_191[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_198 = llvm.extractvalue %x_191[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_199 = llvm.extractvalue %x_191[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_200 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_201 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_202 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_203 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_204 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_205 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_206 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_207 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_208 = llvm.mlir.undef : vector<4xi32> loc(#loc25)
    %x_209 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc25)
    %x_210 = llvm.bitcast %x_192 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc25)
    llvm.cond_br %x_200, ^bb1, ^bb2(%x_209 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_211 = llvm.load %x_210 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_211 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_212: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_213 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_214 = llvm.extractelement %x_212[%x_213 : i32] : vector<4xi32> loc(#loc25)
    %x_215 = llvm.bitcast %x_214 : i32 to vector<1xf32> loc(#loc25)
    %x_216 = llvm.mlir.constant(1 : i32) : i32 loc(#loc25)
    %x_217 = llvm.extractelement %x_212[%x_216 : i32] : vector<4xi32> loc(#loc25)
    %x_218 = llvm.bitcast %x_217 : i32 to vector<1xf32> loc(#loc25)
    %x_219 = llvm.mlir.constant(2 : i32) : i32 loc(#loc25)
    %x_220 = llvm.extractelement %x_212[%x_219 : i32] : vector<4xi32> loc(#loc25)
    %x_221 = llvm.bitcast %x_220 : i32 to vector<1xf32> loc(#loc25)
    %x_222 = llvm.mlir.constant(3 : i32) : i32 loc(#loc25)
    %x_223 = llvm.extractelement %x_212[%x_222 : i32] : vector<4xi32> loc(#loc25)
    %x_224 = llvm.bitcast %x_223 : i32 to vector<1xf32> loc(#loc25)
    %x_225 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_226 = llvm.extractelement %x_215[%x_225 : i32] : vector<1xf32> loc(#loc25)
    %x_227 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_228 = llvm.extractelement %x_218[%x_227 : i32] : vector<1xf32> loc(#loc25)
    %x_229 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_230 = llvm.extractelement %x_221[%x_229 : i32] : vector<1xf32> loc(#loc25)
    %x_231 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_232 = llvm.extractelement %x_224[%x_231 : i32] : vector<1xf32> loc(#loc25)
    %x_233 = llvm.mlir.undef : vector<4xi32> loc(#loc25)
    %x_234 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc25)
    %x_235 = llvm.bitcast %x_196 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc25)
    llvm.cond_br %x_204, ^bb3, ^bb4(%x_234 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_236 = llvm.load %x_235 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_236 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_237: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_238 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_239 = llvm.extractelement %x_237[%x_238 : i32] : vector<4xi32> loc(#loc25)
    %x_240 = llvm.bitcast %x_239 : i32 to vector<1xf32> loc(#loc25)
    %x_241 = llvm.mlir.constant(1 : i32) : i32 loc(#loc25)
    %x_242 = llvm.extractelement %x_237[%x_241 : i32] : vector<4xi32> loc(#loc25)
    %x_243 = llvm.bitcast %x_242 : i32 to vector<1xf32> loc(#loc25)
    %x_244 = llvm.mlir.constant(2 : i32) : i32 loc(#loc25)
    %x_245 = llvm.extractelement %x_237[%x_244 : i32] : vector<4xi32> loc(#loc25)
    %x_246 = llvm.bitcast %x_245 : i32 to vector<1xf32> loc(#loc25)
    %x_247 = llvm.mlir.constant(3 : i32) : i32 loc(#loc25)
    %x_248 = llvm.extractelement %x_237[%x_247 : i32] : vector<4xi32> loc(#loc25)
    %x_249 = llvm.bitcast %x_248 : i32 to vector<1xf32> loc(#loc25)
    %x_250 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_251 = llvm.extractelement %x_240[%x_250 : i32] : vector<1xf32> loc(#loc25)
    %x_252 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_253 = llvm.extractelement %x_243[%x_252 : i32] : vector<1xf32> loc(#loc25)
    %x_254 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_255 = llvm.extractelement %x_246[%x_254 : i32] : vector<1xf32> loc(#loc25)
    %x_256 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_257 = llvm.extractelement %x_249[%x_256 : i32] : vector<1xf32> loc(#loc25)
    %x_258 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc25)
    %x_259 = llvm.insertvalue %x_226, %x_258[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_260 = llvm.insertvalue %x_228, %x_259[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_261 = llvm.insertvalue %x_230, %x_260[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_262 = llvm.insertvalue %x_232, %x_261[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_263 = llvm.insertvalue %x_251, %x_262[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_264 = llvm.insertvalue %x_253, %x_263[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_265 = llvm.insertvalue %x_255, %x_264[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_266 = llvm.insertvalue %x_257, %x_265[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %y = llvm.bitcast %y_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc26)
    %y_267 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc26)
    %y_268 = llvm.insertvalue %y, %y_267[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_269 = llvm.insertvalue %y, %y_268[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_270 = llvm.insertvalue %y, %y_269[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_271 = llvm.insertvalue %y, %y_270[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_272 = llvm.insertvalue %y, %y_271[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_273 = llvm.insertvalue %y, %y_272[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_274 = llvm.insertvalue %y, %y_273[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_275 = llvm.insertvalue %y, %y_274[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_276 = llvm.extractvalue %y_275[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_277 = llvm.extractvalue %y_275[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_278 = llvm.extractvalue %y_275[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_279 = llvm.extractvalue %y_275[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_280 = llvm.extractvalue %y_275[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_281 = llvm.extractvalue %y_275[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_282 = llvm.extractvalue %y_275[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_283 = llvm.extractvalue %y_275[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_284 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_285 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_286 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_287 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_288 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_289 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_290 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_291 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_292 = llvm.getelementptr %y_276[%y_284] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_293 = llvm.getelementptr %y_277[%y_285] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_294 = llvm.getelementptr %y_278[%y_286] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_295 = llvm.getelementptr %y_279[%y_287] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_296 = llvm.getelementptr %y_280[%y_288] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_297 = llvm.getelementptr %y_281[%y_289] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_298 = llvm.getelementptr %y_282[%y_290] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_299 = llvm.getelementptr %y_283[%y_291] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_300 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc26)
    %y_301 = llvm.insertvalue %y_292, %y_300[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_302 = llvm.insertvalue %y_293, %y_301[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_303 = llvm.insertvalue %y_294, %y_302[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_304 = llvm.insertvalue %y_295, %y_303[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_305 = llvm.insertvalue %y_296, %y_304[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_306 = llvm.insertvalue %y_297, %y_305[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_307 = llvm.insertvalue %y_298, %y_306[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_308 = llvm.insertvalue %y_299, %y_307[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_309 = llvm.extractvalue %y_308[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_310 = llvm.extractvalue %y_308[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_311 = llvm.extractvalue %y_308[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_312 = llvm.extractvalue %y_308[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_313 = llvm.extractvalue %y_308[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_314 = llvm.extractvalue %y_308[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_315 = llvm.extractvalue %y_308[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_316 = llvm.extractvalue %y_308[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_317 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_318 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_319 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_320 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_321 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_322 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_323 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_324 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_325 = llvm.mlir.undef : vector<4xi32> loc(#loc27)
    %y_326 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc27)
    %y_327 = llvm.bitcast %y_309 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc27)
    llvm.cond_br %y_317, ^bb5, ^bb6(%y_326 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_328 = llvm.load %y_327 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_328 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_329: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_330 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_331 = llvm.extractelement %y_329[%y_330 : i32] : vector<4xi32> loc(#loc27)
    %y_332 = llvm.bitcast %y_331 : i32 to vector<1xf32> loc(#loc27)
    %y_333 = llvm.mlir.constant(1 : i32) : i32 loc(#loc27)
    %y_334 = llvm.extractelement %y_329[%y_333 : i32] : vector<4xi32> loc(#loc27)
    %y_335 = llvm.bitcast %y_334 : i32 to vector<1xf32> loc(#loc27)
    %y_336 = llvm.mlir.constant(2 : i32) : i32 loc(#loc27)
    %y_337 = llvm.extractelement %y_329[%y_336 : i32] : vector<4xi32> loc(#loc27)
    %y_338 = llvm.bitcast %y_337 : i32 to vector<1xf32> loc(#loc27)
    %y_339 = llvm.mlir.constant(3 : i32) : i32 loc(#loc27)
    %y_340 = llvm.extractelement %y_329[%y_339 : i32] : vector<4xi32> loc(#loc27)
    %y_341 = llvm.bitcast %y_340 : i32 to vector<1xf32> loc(#loc27)
    %y_342 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_343 = llvm.extractelement %y_332[%y_342 : i32] : vector<1xf32> loc(#loc27)
    %y_344 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_345 = llvm.extractelement %y_335[%y_344 : i32] : vector<1xf32> loc(#loc27)
    %y_346 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_347 = llvm.extractelement %y_338[%y_346 : i32] : vector<1xf32> loc(#loc27)
    %y_348 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_349 = llvm.extractelement %y_341[%y_348 : i32] : vector<1xf32> loc(#loc27)
    %y_350 = llvm.mlir.undef : vector<4xi32> loc(#loc27)
    %y_351 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc27)
    %y_352 = llvm.bitcast %y_313 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc27)
    llvm.cond_br %y_321, ^bb7, ^bb8(%y_351 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_353 = llvm.load %y_352 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_353 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_354: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_355 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_356 = llvm.extractelement %y_354[%y_355 : i32] : vector<4xi32> loc(#loc27)
    %y_357 = llvm.bitcast %y_356 : i32 to vector<1xf32> loc(#loc27)
    %y_358 = llvm.mlir.constant(1 : i32) : i32 loc(#loc27)
    %y_359 = llvm.extractelement %y_354[%y_358 : i32] : vector<4xi32> loc(#loc27)
    %y_360 = llvm.bitcast %y_359 : i32 to vector<1xf32> loc(#loc27)
    %y_361 = llvm.mlir.constant(2 : i32) : i32 loc(#loc27)
    %y_362 = llvm.extractelement %y_354[%y_361 : i32] : vector<4xi32> loc(#loc27)
    %y_363 = llvm.bitcast %y_362 : i32 to vector<1xf32> loc(#loc27)
    %y_364 = llvm.mlir.constant(3 : i32) : i32 loc(#loc27)
    %y_365 = llvm.extractelement %y_354[%y_364 : i32] : vector<4xi32> loc(#loc27)
    %y_366 = llvm.bitcast %y_365 : i32 to vector<1xf32> loc(#loc27)
    %y_367 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_368 = llvm.extractelement %y_357[%y_367 : i32] : vector<1xf32> loc(#loc27)
    %y_369 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_370 = llvm.extractelement %y_360[%y_369 : i32] : vector<1xf32> loc(#loc27)
    %y_371 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_372 = llvm.extractelement %y_363[%y_371 : i32] : vector<1xf32> loc(#loc27)
    %y_373 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_374 = llvm.extractelement %y_366[%y_373 : i32] : vector<1xf32> loc(#loc27)
    %y_375 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc27)
    %y_376 = llvm.insertvalue %y_343, %y_375[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_377 = llvm.insertvalue %y_345, %y_376[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_378 = llvm.insertvalue %y_347, %y_377[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_379 = llvm.insertvalue %y_349, %y_378[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_380 = llvm.insertvalue %y_368, %y_379[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_381 = llvm.insertvalue %y_370, %y_380[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_382 = llvm.insertvalue %y_372, %y_381[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_383 = llvm.insertvalue %y_374, %y_382[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %output = llvm.extractvalue %x_266[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_384 = llvm.extractvalue %x_266[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_385 = llvm.extractvalue %x_266[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_386 = llvm.extractvalue %x_266[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_387 = llvm.extractvalue %x_266[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_388 = llvm.extractvalue %x_266[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_389 = llvm.extractvalue %x_266[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_390 = llvm.extractvalue %x_266[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_391 = llvm.extractvalue %y_383[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_392 = llvm.extractvalue %y_383[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_393 = llvm.extractvalue %y_383[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_394 = llvm.extractvalue %y_383[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_395 = llvm.extractvalue %y_383[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_396 = llvm.extractvalue %y_383[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_397 = llvm.extractvalue %y_383[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_398 = llvm.extractvalue %y_383[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_399 = llvm.fadd %output, %output_391 : f32 loc(#loc28)
    %output_400 = llvm.fadd %output_384, %output_392 : f32 loc(#loc28)
    %output_401 = llvm.fadd %output_385, %output_393 : f32 loc(#loc28)
    %output_402 = llvm.fadd %output_386, %output_394 : f32 loc(#loc28)
    %output_403 = llvm.fadd %output_387, %output_395 : f32 loc(#loc28)
    %output_404 = llvm.fadd %output_388, %output_396 : f32 loc(#loc28)
    %output_405 = llvm.fadd %output_389, %output_397 : f32 loc(#loc28)
    %output_406 = llvm.fadd %output_390, %output_398 : f32 loc(#loc28)
    %output_407 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc28)
    %output_408 = llvm.insertvalue %output_399, %output_407[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_409 = llvm.insertvalue %output_400, %output_408[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_410 = llvm.insertvalue %output_401, %output_409[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_411 = llvm.insertvalue %output_402, %output_410[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_412 = llvm.insertvalue %output_403, %output_411[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_413 = llvm.insertvalue %output_404, %output_412[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_414 = llvm.insertvalue %output_405, %output_413[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_415 = llvm.insertvalue %output_406, %output_414[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1 = llvm.bitcast %output_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc12)
    %2 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc12)
    %3 = llvm.insertvalue %1, %2[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %4 = llvm.insertvalue %1, %3[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %5 = llvm.insertvalue %1, %4[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %6 = llvm.insertvalue %1, %5[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %7 = llvm.insertvalue %1, %6[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %8 = llvm.insertvalue %1, %7[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %9 = llvm.insertvalue %1, %8[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %10 = llvm.insertvalue %1, %9[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %11 = llvm.extractvalue %10[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %12 = llvm.extractvalue %10[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %13 = llvm.extractvalue %10[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %14 = llvm.extractvalue %10[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %15 = llvm.extractvalue %10[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %16 = llvm.extractvalue %10[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %17 = llvm.extractvalue %10[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %18 = llvm.extractvalue %10[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %19 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %20 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %21 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %22 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %23 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %24 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %25 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %26 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %27 = llvm.getelementptr %11[%19] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %28 = llvm.getelementptr %12[%20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %29 = llvm.getelementptr %13[%21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %30 = llvm.getelementptr %14[%22] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %31 = llvm.getelementptr %15[%23] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %32 = llvm.getelementptr %16[%24] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %33 = llvm.getelementptr %17[%25] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %34 = llvm.getelementptr %18[%26] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %35 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc12)
    %36 = llvm.insertvalue %27, %35[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %37 = llvm.insertvalue %28, %36[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %38 = llvm.insertvalue %29, %37[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %39 = llvm.insertvalue %30, %38[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %40 = llvm.insertvalue %31, %39[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %41 = llvm.insertvalue %32, %40[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %42 = llvm.insertvalue %33, %41[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %43 = llvm.insertvalue %34, %42[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %44 = llvm.extractvalue %43[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %45 = llvm.extractvalue %43[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %46 = llvm.extractvalue %43[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %47 = llvm.extractvalue %43[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %48 = llvm.extractvalue %43[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %49 = llvm.extractvalue %43[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %50 = llvm.extractvalue %43[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %51 = llvm.extractvalue %43[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %52 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %53 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %54 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %55 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %56 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %57 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %58 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %59 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %60 = llvm.extractvalue %output_415[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %61 = llvm.extractvalue %output_415[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %62 = llvm.extractvalue %output_415[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %63 = llvm.extractvalue %output_415[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %64 = llvm.extractvalue %output_415[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %65 = llvm.extractvalue %output_415[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %66 = llvm.extractvalue %output_415[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %67 = llvm.extractvalue %output_415[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %68 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %69 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %70 = llvm.call spir_funccc @_Z12get_local_idj(%69) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %71 = llvm.trunc %70 : i64 to i32 loc(#loc13)
    %72 = llvm.mlir.constant(127 : i32) : i32 loc(#loc13)
    %73 = llvm.and %71, %72 : i32 loc(#loc13)
    %74 = llvm.mlir.constant(32 : i32) : i32 loc(#loc13)
    %75 = llvm.urem %73, %74 : i32 loc(#loc13)
    %76 = llvm.udiv %73, %74 : i32 loc(#loc13)
    %77 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %78 = llvm.bitcast %60 : f32 to f32 loc(#loc13)
    %79 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %80 = llvm.insertelement %78, %77[%79 : i32] : vector<1xf32> loc(#loc13)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc13)
    %82 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %83 = llvm.bitcast %61 : f32 to f32 loc(#loc13)
    %84 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %85 = llvm.insertelement %83, %82[%84 : i32] : vector<1xf32> loc(#loc13)
    %86 = llvm.bitcast %85 : vector<1xf32> to i32 loc(#loc13)
    %87 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %88 = llvm.bitcast %62 : f32 to f32 loc(#loc13)
    %89 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %90 = llvm.insertelement %88, %87[%89 : i32] : vector<1xf32> loc(#loc13)
    %91 = llvm.bitcast %90 : vector<1xf32> to i32 loc(#loc13)
    %92 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %93 = llvm.bitcast %63 : f32 to f32 loc(#loc13)
    %94 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %95 = llvm.insertelement %93, %92[%94 : i32] : vector<1xf32> loc(#loc13)
    %96 = llvm.bitcast %95 : vector<1xf32> to i32 loc(#loc13)
    %97 = llvm.mlir.undef : vector<4xi32> loc(#loc13)
    %98 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %99 = llvm.insertelement %81, %97[%98 : i32] : vector<4xi32> loc(#loc13)
    %100 = llvm.mlir.constant(1 : i32) : i32 loc(#loc13)
    %101 = llvm.insertelement %86, %99[%100 : i32] : vector<4xi32> loc(#loc13)
    %102 = llvm.mlir.constant(2 : i32) : i32 loc(#loc13)
    %103 = llvm.insertelement %91, %101[%102 : i32] : vector<4xi32> loc(#loc13)
    %104 = llvm.mlir.constant(3 : i32) : i32 loc(#loc13)
    %105 = llvm.insertelement %96, %103[%104 : i32] : vector<4xi32> loc(#loc13)
    %106 = llvm.bitcast %44 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc13)
    llvm.cond_br %52, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %105, %106 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %107 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %108 = llvm.bitcast %64 : f32 to f32 loc(#loc13)
    %109 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %110 = llvm.insertelement %108, %107[%109 : i32] : vector<1xf32> loc(#loc13)
    %111 = llvm.bitcast %110 : vector<1xf32> to i32 loc(#loc13)
    %112 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %113 = llvm.bitcast %65 : f32 to f32 loc(#loc13)
    %114 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %115 = llvm.insertelement %113, %112[%114 : i32] : vector<1xf32> loc(#loc13)
    %116 = llvm.bitcast %115 : vector<1xf32> to i32 loc(#loc13)
    %117 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %118 = llvm.bitcast %66 : f32 to f32 loc(#loc13)
    %119 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %120 = llvm.insertelement %118, %117[%119 : i32] : vector<1xf32> loc(#loc13)
    %121 = llvm.bitcast %120 : vector<1xf32> to i32 loc(#loc13)
    %122 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %123 = llvm.bitcast %67 : f32 to f32 loc(#loc13)
    %124 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %125 = llvm.insertelement %123, %122[%124 : i32] : vector<1xf32> loc(#loc13)
    %126 = llvm.bitcast %125 : vector<1xf32> to i32 loc(#loc13)
    %127 = llvm.mlir.undef : vector<4xi32> loc(#loc13)
    %128 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %129 = llvm.insertelement %111, %127[%128 : i32] : vector<4xi32> loc(#loc13)
    %130 = llvm.mlir.constant(1 : i32) : i32 loc(#loc13)
    %131 = llvm.insertelement %116, %129[%130 : i32] : vector<4xi32> loc(#loc13)
    %132 = llvm.mlir.constant(2 : i32) : i32 loc(#loc13)
    %133 = llvm.insertelement %121, %131[%132 : i32] : vector<4xi32> loc(#loc13)
    %134 = llvm.mlir.constant(3 : i32) : i32 loc(#loc13)
    %135 = llvm.insertelement %126, %133[%134 : i32] : vector<4xi32> loc(#loc13)
    %136 = llvm.bitcast %48 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc13)
    llvm.cond_br %56, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %135, %136 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %output_ptr_0 = builtin.unrealized_conversion_cast %output_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc17)
    %y_ptr_1 = builtin.unrealized_conversion_cast %y_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc16)
    %x_ptr_2 = builtin.unrealized_conversion_cast %x_ptr : !llvm.ptr<1> to !tt.ptr<f32> loc(#loc15)
    %0 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.mlir.constant(0 : i32) : i32 loc(#loc19)
    %pid_3 = llvm.call spir_funccc @_Z12get_group_idj(%pid) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %pid_4 = llvm.trunc %pid_3 : i64 to i32 loc(#loc19)
    %block_start = llvm.mul %pid_4, %0 : i32 loc(#loc20)
    %offsets = llvm.mlir.constant(0 : index) : i32 loc(#loc21)
    %offsets_5 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_6 = llvm.call spir_funccc @_Z12get_local_idj(%offsets_5) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc21)
    %offsets_7 = llvm.trunc %offsets_6 : i64 to i32 loc(#loc21)
    %offsets_8 = llvm.mlir.constant(127 : i32) : i32 loc(#loc21)
    %offsets_9 = llvm.and %offsets_7, %offsets_8 : i32 loc(#loc21)
    %offsets_10 = llvm.mlir.constant(32 : i32) : i32 loc(#loc21)
    %offsets_11 = llvm.urem %offsets_9, %offsets_10 : i32 loc(#loc21)
    %offsets_12 = llvm.udiv %offsets_9, %offsets_10 : i32 loc(#loc21)
    %offsets_13 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_14 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_15 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_16 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_17 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_18 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_19 = llvm.shl %offsets_11, %offsets_18 : i32 loc(#loc21)
    %offsets_20 = llvm.or %offsets_17, %offsets_19 : i32 loc(#loc21)
    %offsets_21 = llvm.mlir.constant(5 : i32) : i32 loc(#loc21)
    %offsets_22 = llvm.shl %offsets_12, %offsets_21 : i32 loc(#loc21)
    %offsets_23 = llvm.or %offsets_20, %offsets_22 : i32 loc(#loc21)
    %offsets_24 = llvm.mlir.constant(127 : i32) : i32 loc(#loc21)
    %offsets_25 = llvm.and %offsets_23, %offsets_24 : i32 loc(#loc21)
    %offsets_26 = llvm.mlir.constant(2 : i32) : i32 loc(#loc21)
    %offsets_27 = llvm.shl %offsets_25, %offsets_26 : i32 loc(#loc21)
    %offsets_28 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_29 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_30 = llvm.or disjoint %offsets_27, %offsets_29 : i32 loc(#loc21)
    %offsets_31 = llvm.xor %offsets_16, %offsets_30 : i32 loc(#loc21)
    %offsets_32 = llvm.mlir.constant(0 : i32) : i32 loc(#loc21)
    %offsets_33 = llvm.xor %offsets_31, %offsets_32 : i32 loc(#loc21)
    %offsets_34 = llvm.mlir.constant(1 : i32) : i32 loc(#loc21)
    %offsets_35 = llvm.xor %offsets_31, %offsets_34 : i32 loc(#loc21)
    %offsets_36 = llvm.mlir.constant(2 : i32) : i32 loc(#loc21)
    %offsets_37 = llvm.xor %offsets_31, %offsets_36 : i32 loc(#loc21)
    %offsets_38 = llvm.mlir.constant(3 : i32) : i32 loc(#loc21)
    %offsets_39 = llvm.xor %offsets_31, %offsets_38 : i32 loc(#loc21)
    %offsets_40 = llvm.mlir.constant(512 : i32) : i32 loc(#loc21)
    %offsets_41 = llvm.xor %offsets_31, %offsets_40 : i32 loc(#loc21)
    %offsets_42 = llvm.mlir.constant(513 : i32) : i32 loc(#loc21)
    %offsets_43 = llvm.xor %offsets_31, %offsets_42 : i32 loc(#loc21)
    %offsets_44 = llvm.mlir.constant(514 : i32) : i32 loc(#loc21)
    %offsets_45 = llvm.xor %offsets_31, %offsets_44 : i32 loc(#loc21)
    %offsets_46 = llvm.mlir.constant(515 : i32) : i32 loc(#loc21)
    %offsets_47 = llvm.xor %offsets_31, %offsets_46 : i32 loc(#loc21)
    %offsets_48 = llvm.add %offsets_33, %offsets : i32 loc(#loc21)
    %offsets_49 = llvm.add %offsets_35, %offsets : i32 loc(#loc21)
    %offsets_50 = llvm.add %offsets_37, %offsets : i32 loc(#loc21)
    %offsets_51 = llvm.add %offsets_39, %offsets : i32 loc(#loc21)
    %offsets_52 = llvm.add %offsets_41, %offsets : i32 loc(#loc21)
    %offsets_53 = llvm.add %offsets_43, %offsets : i32 loc(#loc21)
    %offsets_54 = llvm.add %offsets_45, %offsets : i32 loc(#loc21)
    %offsets_55 = llvm.add %offsets_47, %offsets : i32 loc(#loc21)
    %offsets_56 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc21)
    %offsets_57 = llvm.insertvalue %offsets_48, %offsets_56[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_58 = llvm.insertvalue %offsets_49, %offsets_57[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_59 = llvm.insertvalue %offsets_50, %offsets_58[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_60 = llvm.insertvalue %offsets_51, %offsets_59[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_61 = llvm.insertvalue %offsets_52, %offsets_60[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_62 = llvm.insertvalue %offsets_53, %offsets_61[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_63 = llvm.insertvalue %offsets_54, %offsets_62[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_64 = llvm.insertvalue %offsets_55, %offsets_63[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc21)
    %offsets_65 = llvm.bitcast %block_start : i32 to i32 loc(#loc22)
    %offsets_66 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc22)
    %offsets_67 = llvm.insertvalue %offsets_65, %offsets_66[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_68 = llvm.insertvalue %offsets_65, %offsets_67[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_69 = llvm.insertvalue %offsets_65, %offsets_68[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_70 = llvm.insertvalue %offsets_65, %offsets_69[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_71 = llvm.insertvalue %offsets_65, %offsets_70[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_72 = llvm.insertvalue %offsets_65, %offsets_71[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_73 = llvm.insertvalue %offsets_65, %offsets_72[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_74 = llvm.insertvalue %offsets_65, %offsets_73[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_75 = llvm.extractvalue %offsets_74[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_76 = llvm.extractvalue %offsets_74[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_77 = llvm.extractvalue %offsets_74[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_78 = llvm.extractvalue %offsets_74[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_79 = llvm.extractvalue %offsets_74[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_80 = llvm.extractvalue %offsets_74[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_81 = llvm.extractvalue %offsets_74[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_82 = llvm.extractvalue %offsets_74[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_83 = llvm.extractvalue %offsets_64[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_84 = llvm.extractvalue %offsets_64[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_85 = llvm.extractvalue %offsets_64[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_86 = llvm.extractvalue %offsets_64[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_87 = llvm.extractvalue %offsets_64[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_88 = llvm.extractvalue %offsets_64[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_89 = llvm.extractvalue %offsets_64[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_90 = llvm.extractvalue %offsets_64[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_91 = llvm.add %offsets_75, %offsets_83 : i32 loc(#loc22)
    %offsets_92 = llvm.add %offsets_76, %offsets_84 : i32 loc(#loc22)
    %offsets_93 = llvm.add %offsets_77, %offsets_85 : i32 loc(#loc22)
    %offsets_94 = llvm.add %offsets_78, %offsets_86 : i32 loc(#loc22)
    %offsets_95 = llvm.add %offsets_79, %offsets_87 : i32 loc(#loc22)
    %offsets_96 = llvm.add %offsets_80, %offsets_88 : i32 loc(#loc22)
    %offsets_97 = llvm.add %offsets_81, %offsets_89 : i32 loc(#loc22)
    %offsets_98 = llvm.add %offsets_82, %offsets_90 : i32 loc(#loc22)
    %offsets_99 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc22)
    %offsets_100 = llvm.insertvalue %offsets_91, %offsets_99[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_101 = llvm.insertvalue %offsets_92, %offsets_100[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_102 = llvm.insertvalue %offsets_93, %offsets_101[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_103 = llvm.insertvalue %offsets_94, %offsets_102[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_104 = llvm.insertvalue %offsets_95, %offsets_103[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_105 = llvm.insertvalue %offsets_96, %offsets_104[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_106 = llvm.insertvalue %offsets_97, %offsets_105[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %offsets_107 = llvm.insertvalue %offsets_98, %offsets_106[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc22)
    %mask = llvm.bitcast %n_elements : i32 to i32 loc(#loc23)
    %mask_108 = llvm.mlir.undef : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)> loc(#loc23)
    %mask_109 = llvm.insertvalue %mask, %mask_108[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_110 = llvm.insertvalue %mask, %mask_109[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_111 = llvm.insertvalue %mask, %mask_110[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_112 = llvm.insertvalue %mask, %mask_111[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_113 = llvm.insertvalue %mask, %mask_112[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_114 = llvm.insertvalue %mask, %mask_113[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_115 = llvm.insertvalue %mask, %mask_114[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_116 = llvm.insertvalue %mask, %mask_115[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_117 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_118 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_119 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_120 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_121 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_122 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_123 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_124 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_125 = llvm.extractvalue %mask_116[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_126 = llvm.extractvalue %mask_116[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_127 = llvm.extractvalue %mask_116[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_128 = llvm.extractvalue %mask_116[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_129 = llvm.extractvalue %mask_116[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_130 = llvm.extractvalue %mask_116[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_131 = llvm.extractvalue %mask_116[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_132 = llvm.extractvalue %mask_116[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc23)
    %mask_133 = llvm.icmp "slt" %mask_117, %mask_125 : i32 loc(#loc23)
    %mask_134 = llvm.icmp "slt" %mask_118, %mask_126 : i32 loc(#loc23)
    %mask_135 = llvm.icmp "slt" %mask_119, %mask_127 : i32 loc(#loc23)
    %mask_136 = llvm.icmp "slt" %mask_120, %mask_128 : i32 loc(#loc23)
    %mask_137 = llvm.icmp "slt" %mask_121, %mask_129 : i32 loc(#loc23)
    %mask_138 = llvm.icmp "slt" %mask_122, %mask_130 : i32 loc(#loc23)
    %mask_139 = llvm.icmp "slt" %mask_123, %mask_131 : i32 loc(#loc23)
    %mask_140 = llvm.icmp "slt" %mask_124, %mask_132 : i32 loc(#loc23)
    %mask_141 = llvm.mlir.undef : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)> loc(#loc23)
    %mask_142 = llvm.insertvalue %mask_133, %mask_141[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_143 = llvm.insertvalue %mask_133, %mask_142[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_144 = llvm.insertvalue %mask_133, %mask_143[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_145 = llvm.insertvalue %mask_133, %mask_144[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_146 = llvm.insertvalue %mask_137, %mask_145[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_147 = llvm.insertvalue %mask_137, %mask_146[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_148 = llvm.insertvalue %mask_137, %mask_147[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %mask_149 = llvm.insertvalue %mask_137, %mask_148[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc23)
    %x = llvm.bitcast %x_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc24)
    %x_150 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc24)
    %x_151 = llvm.insertvalue %x, %x_150[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_152 = llvm.insertvalue %x, %x_151[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_153 = llvm.insertvalue %x, %x_152[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_154 = llvm.insertvalue %x, %x_153[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_155 = llvm.insertvalue %x, %x_154[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_156 = llvm.insertvalue %x, %x_155[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_157 = llvm.insertvalue %x, %x_156[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_158 = llvm.insertvalue %x, %x_157[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_159 = llvm.extractvalue %x_158[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_160 = llvm.extractvalue %x_158[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_161 = llvm.extractvalue %x_158[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_162 = llvm.extractvalue %x_158[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_163 = llvm.extractvalue %x_158[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_164 = llvm.extractvalue %x_158[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_165 = llvm.extractvalue %x_158[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_166 = llvm.extractvalue %x_158[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_167 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_168 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_169 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_170 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_171 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_172 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_173 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_174 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc24)
    %x_175 = llvm.getelementptr %x_159[%x_167] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_176 = llvm.getelementptr %x_160[%x_168] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_177 = llvm.getelementptr %x_161[%x_169] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_178 = llvm.getelementptr %x_162[%x_170] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_179 = llvm.getelementptr %x_163[%x_171] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_180 = llvm.getelementptr %x_164[%x_172] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_181 = llvm.getelementptr %x_165[%x_173] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_182 = llvm.getelementptr %x_166[%x_174] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_183 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc24)
    %x_184 = llvm.insertvalue %x_175, %x_183[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_185 = llvm.insertvalue %x_176, %x_184[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_186 = llvm.insertvalue %x_177, %x_185[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_187 = llvm.insertvalue %x_178, %x_186[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_188 = llvm.insertvalue %x_179, %x_187[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_189 = llvm.insertvalue %x_180, %x_188[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_190 = llvm.insertvalue %x_181, %x_189[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_191 = llvm.insertvalue %x_182, %x_190[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc24)
    %x_192 = llvm.extractvalue %x_191[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_193 = llvm.extractvalue %x_191[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_194 = llvm.extractvalue %x_191[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_195 = llvm.extractvalue %x_191[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_196 = llvm.extractvalue %x_191[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_197 = llvm.extractvalue %x_191[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_198 = llvm.extractvalue %x_191[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_199 = llvm.extractvalue %x_191[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc25)
    %x_200 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_201 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_202 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_203 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_204 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_205 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_206 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_207 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc25)
    %x_208 = llvm.mlir.undef : vector<4xi32> loc(#loc25)
    %x_209 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc25)
    %x_210 = llvm.bitcast %x_192 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc25)
    llvm.cond_br %x_200, ^bb1, ^bb2(%x_209 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_211 = llvm.load %x_210 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_211 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_212: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_213 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_214 = llvm.extractelement %x_212[%x_213 : i32] : vector<4xi32> loc(#loc25)
    %x_215 = llvm.bitcast %x_214 : i32 to vector<1xf32> loc(#loc25)
    %x_216 = llvm.mlir.constant(1 : i32) : i32 loc(#loc25)
    %x_217 = llvm.extractelement %x_212[%x_216 : i32] : vector<4xi32> loc(#loc25)
    %x_218 = llvm.bitcast %x_217 : i32 to vector<1xf32> loc(#loc25)
    %x_219 = llvm.mlir.constant(2 : i32) : i32 loc(#loc25)
    %x_220 = llvm.extractelement %x_212[%x_219 : i32] : vector<4xi32> loc(#loc25)
    %x_221 = llvm.bitcast %x_220 : i32 to vector<1xf32> loc(#loc25)
    %x_222 = llvm.mlir.constant(3 : i32) : i32 loc(#loc25)
    %x_223 = llvm.extractelement %x_212[%x_222 : i32] : vector<4xi32> loc(#loc25)
    %x_224 = llvm.bitcast %x_223 : i32 to vector<1xf32> loc(#loc25)
    %x_225 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_226 = llvm.extractelement %x_215[%x_225 : i32] : vector<1xf32> loc(#loc25)
    %x_227 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_228 = llvm.extractelement %x_218[%x_227 : i32] : vector<1xf32> loc(#loc25)
    %x_229 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_230 = llvm.extractelement %x_221[%x_229 : i32] : vector<1xf32> loc(#loc25)
    %x_231 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_232 = llvm.extractelement %x_224[%x_231 : i32] : vector<1xf32> loc(#loc25)
    %x_233 = llvm.mlir.undef : vector<4xi32> loc(#loc25)
    %x_234 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc25)
    %x_235 = llvm.bitcast %x_196 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc25)
    llvm.cond_br %x_204, ^bb3, ^bb4(%x_234 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_236 = llvm.load %x_235 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_236 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_237: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_238 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_239 = llvm.extractelement %x_237[%x_238 : i32] : vector<4xi32> loc(#loc25)
    %x_240 = llvm.bitcast %x_239 : i32 to vector<1xf32> loc(#loc25)
    %x_241 = llvm.mlir.constant(1 : i32) : i32 loc(#loc25)
    %x_242 = llvm.extractelement %x_237[%x_241 : i32] : vector<4xi32> loc(#loc25)
    %x_243 = llvm.bitcast %x_242 : i32 to vector<1xf32> loc(#loc25)
    %x_244 = llvm.mlir.constant(2 : i32) : i32 loc(#loc25)
    %x_245 = llvm.extractelement %x_237[%x_244 : i32] : vector<4xi32> loc(#loc25)
    %x_246 = llvm.bitcast %x_245 : i32 to vector<1xf32> loc(#loc25)
    %x_247 = llvm.mlir.constant(3 : i32) : i32 loc(#loc25)
    %x_248 = llvm.extractelement %x_237[%x_247 : i32] : vector<4xi32> loc(#loc25)
    %x_249 = llvm.bitcast %x_248 : i32 to vector<1xf32> loc(#loc25)
    %x_250 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_251 = llvm.extractelement %x_240[%x_250 : i32] : vector<1xf32> loc(#loc25)
    %x_252 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_253 = llvm.extractelement %x_243[%x_252 : i32] : vector<1xf32> loc(#loc25)
    %x_254 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_255 = llvm.extractelement %x_246[%x_254 : i32] : vector<1xf32> loc(#loc25)
    %x_256 = llvm.mlir.constant(0 : i32) : i32 loc(#loc25)
    %x_257 = llvm.extractelement %x_249[%x_256 : i32] : vector<1xf32> loc(#loc25)
    %x_258 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc25)
    %x_259 = llvm.insertvalue %x_226, %x_258[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_260 = llvm.insertvalue %x_228, %x_259[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_261 = llvm.insertvalue %x_230, %x_260[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_262 = llvm.insertvalue %x_232, %x_261[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_263 = llvm.insertvalue %x_251, %x_262[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_264 = llvm.insertvalue %x_253, %x_263[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_265 = llvm.insertvalue %x_255, %x_264[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %x_266 = llvm.insertvalue %x_257, %x_265[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc25)
    %y = llvm.bitcast %y_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc26)
    %y_267 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc26)
    %y_268 = llvm.insertvalue %y, %y_267[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_269 = llvm.insertvalue %y, %y_268[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_270 = llvm.insertvalue %y, %y_269[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_271 = llvm.insertvalue %y, %y_270[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_272 = llvm.insertvalue %y, %y_271[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_273 = llvm.insertvalue %y, %y_272[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_274 = llvm.insertvalue %y, %y_273[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_275 = llvm.insertvalue %y, %y_274[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_276 = llvm.extractvalue %y_275[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_277 = llvm.extractvalue %y_275[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_278 = llvm.extractvalue %y_275[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_279 = llvm.extractvalue %y_275[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_280 = llvm.extractvalue %y_275[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_281 = llvm.extractvalue %y_275[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_282 = llvm.extractvalue %y_275[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_283 = llvm.extractvalue %y_275[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_284 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_285 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_286 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_287 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_288 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_289 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_290 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_291 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc26)
    %y_292 = llvm.getelementptr %y_276[%y_284] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_293 = llvm.getelementptr %y_277[%y_285] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_294 = llvm.getelementptr %y_278[%y_286] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_295 = llvm.getelementptr %y_279[%y_287] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_296 = llvm.getelementptr %y_280[%y_288] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_297 = llvm.getelementptr %y_281[%y_289] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_298 = llvm.getelementptr %y_282[%y_290] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_299 = llvm.getelementptr %y_283[%y_291] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_300 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc26)
    %y_301 = llvm.insertvalue %y_292, %y_300[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_302 = llvm.insertvalue %y_293, %y_301[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_303 = llvm.insertvalue %y_294, %y_302[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_304 = llvm.insertvalue %y_295, %y_303[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_305 = llvm.insertvalue %y_296, %y_304[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_306 = llvm.insertvalue %y_297, %y_305[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_307 = llvm.insertvalue %y_298, %y_306[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_308 = llvm.insertvalue %y_299, %y_307[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc26)
    %y_309 = llvm.extractvalue %y_308[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_310 = llvm.extractvalue %y_308[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_311 = llvm.extractvalue %y_308[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_312 = llvm.extractvalue %y_308[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_313 = llvm.extractvalue %y_308[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_314 = llvm.extractvalue %y_308[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_315 = llvm.extractvalue %y_308[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_316 = llvm.extractvalue %y_308[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc27)
    %y_317 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_318 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_319 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_320 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_321 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_322 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_323 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_324 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc27)
    %y_325 = llvm.mlir.undef : vector<4xi32> loc(#loc27)
    %y_326 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc27)
    %y_327 = llvm.bitcast %y_309 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc27)
    llvm.cond_br %y_317, ^bb5, ^bb6(%y_326 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_328 = llvm.load %y_327 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_328 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_329: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_330 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_331 = llvm.extractelement %y_329[%y_330 : i32] : vector<4xi32> loc(#loc27)
    %y_332 = llvm.bitcast %y_331 : i32 to vector<1xf32> loc(#loc27)
    %y_333 = llvm.mlir.constant(1 : i32) : i32 loc(#loc27)
    %y_334 = llvm.extractelement %y_329[%y_333 : i32] : vector<4xi32> loc(#loc27)
    %y_335 = llvm.bitcast %y_334 : i32 to vector<1xf32> loc(#loc27)
    %y_336 = llvm.mlir.constant(2 : i32) : i32 loc(#loc27)
    %y_337 = llvm.extractelement %y_329[%y_336 : i32] : vector<4xi32> loc(#loc27)
    %y_338 = llvm.bitcast %y_337 : i32 to vector<1xf32> loc(#loc27)
    %y_339 = llvm.mlir.constant(3 : i32) : i32 loc(#loc27)
    %y_340 = llvm.extractelement %y_329[%y_339 : i32] : vector<4xi32> loc(#loc27)
    %y_341 = llvm.bitcast %y_340 : i32 to vector<1xf32> loc(#loc27)
    %y_342 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_343 = llvm.extractelement %y_332[%y_342 : i32] : vector<1xf32> loc(#loc27)
    %y_344 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_345 = llvm.extractelement %y_335[%y_344 : i32] : vector<1xf32> loc(#loc27)
    %y_346 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_347 = llvm.extractelement %y_338[%y_346 : i32] : vector<1xf32> loc(#loc27)
    %y_348 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_349 = llvm.extractelement %y_341[%y_348 : i32] : vector<1xf32> loc(#loc27)
    %y_350 = llvm.mlir.undef : vector<4xi32> loc(#loc27)
    %y_351 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc27)
    %y_352 = llvm.bitcast %y_313 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc27)
    llvm.cond_br %y_321, ^bb7, ^bb8(%y_351 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_353 = llvm.load %y_352 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_353 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_354: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_355 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_356 = llvm.extractelement %y_354[%y_355 : i32] : vector<4xi32> loc(#loc27)
    %y_357 = llvm.bitcast %y_356 : i32 to vector<1xf32> loc(#loc27)
    %y_358 = llvm.mlir.constant(1 : i32) : i32 loc(#loc27)
    %y_359 = llvm.extractelement %y_354[%y_358 : i32] : vector<4xi32> loc(#loc27)
    %y_360 = llvm.bitcast %y_359 : i32 to vector<1xf32> loc(#loc27)
    %y_361 = llvm.mlir.constant(2 : i32) : i32 loc(#loc27)
    %y_362 = llvm.extractelement %y_354[%y_361 : i32] : vector<4xi32> loc(#loc27)
    %y_363 = llvm.bitcast %y_362 : i32 to vector<1xf32> loc(#loc27)
    %y_364 = llvm.mlir.constant(3 : i32) : i32 loc(#loc27)
    %y_365 = llvm.extractelement %y_354[%y_364 : i32] : vector<4xi32> loc(#loc27)
    %y_366 = llvm.bitcast %y_365 : i32 to vector<1xf32> loc(#loc27)
    %y_367 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_368 = llvm.extractelement %y_357[%y_367 : i32] : vector<1xf32> loc(#loc27)
    %y_369 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_370 = llvm.extractelement %y_360[%y_369 : i32] : vector<1xf32> loc(#loc27)
    %y_371 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_372 = llvm.extractelement %y_363[%y_371 : i32] : vector<1xf32> loc(#loc27)
    %y_373 = llvm.mlir.constant(0 : i32) : i32 loc(#loc27)
    %y_374 = llvm.extractelement %y_366[%y_373 : i32] : vector<1xf32> loc(#loc27)
    %y_375 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc27)
    %y_376 = llvm.insertvalue %y_343, %y_375[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_377 = llvm.insertvalue %y_345, %y_376[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_378 = llvm.insertvalue %y_347, %y_377[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_379 = llvm.insertvalue %y_349, %y_378[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_380 = llvm.insertvalue %y_368, %y_379[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_381 = llvm.insertvalue %y_370, %y_380[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_382 = llvm.insertvalue %y_372, %y_381[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %y_383 = llvm.insertvalue %y_374, %y_382[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc27)
    %output = llvm.extractvalue %x_266[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_384 = llvm.extractvalue %x_266[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_385 = llvm.extractvalue %x_266[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_386 = llvm.extractvalue %x_266[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_387 = llvm.extractvalue %x_266[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_388 = llvm.extractvalue %x_266[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_389 = llvm.extractvalue %x_266[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_390 = llvm.extractvalue %x_266[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_391 = llvm.extractvalue %y_383[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_392 = llvm.extractvalue %y_383[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_393 = llvm.extractvalue %y_383[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_394 = llvm.extractvalue %y_383[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_395 = llvm.extractvalue %y_383[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_396 = llvm.extractvalue %y_383[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_397 = llvm.extractvalue %y_383[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_398 = llvm.extractvalue %y_383[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_399 = llvm.fadd %output, %output_391 : f32 loc(#loc28)
    %output_400 = llvm.fadd %output_384, %output_392 : f32 loc(#loc28)
    %output_401 = llvm.fadd %output_385, %output_393 : f32 loc(#loc28)
    %output_402 = llvm.fadd %output_386, %output_394 : f32 loc(#loc28)
    %output_403 = llvm.fadd %output_387, %output_395 : f32 loc(#loc28)
    %output_404 = llvm.fadd %output_388, %output_396 : f32 loc(#loc28)
    %output_405 = llvm.fadd %output_389, %output_397 : f32 loc(#loc28)
    %output_406 = llvm.fadd %output_390, %output_398 : f32 loc(#loc28)
    %output_407 = llvm.mlir.undef : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)> loc(#loc28)
    %output_408 = llvm.insertvalue %output_399, %output_407[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_409 = llvm.insertvalue %output_400, %output_408[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_410 = llvm.insertvalue %output_401, %output_409[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_411 = llvm.insertvalue %output_402, %output_410[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_412 = llvm.insertvalue %output_403, %output_411[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_413 = llvm.insertvalue %output_404, %output_412[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_414 = llvm.insertvalue %output_405, %output_413[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %output_415 = llvm.insertvalue %output_406, %output_414[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc28)
    %1 = llvm.bitcast %output_ptr : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc12)
    %2 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc12)
    %3 = llvm.insertvalue %1, %2[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %4 = llvm.insertvalue %1, %3[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %5 = llvm.insertvalue %1, %4[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %6 = llvm.insertvalue %1, %5[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %7 = llvm.insertvalue %1, %6[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %8 = llvm.insertvalue %1, %7[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %9 = llvm.insertvalue %1, %8[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %10 = llvm.insertvalue %1, %9[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %11 = llvm.extractvalue %10[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %12 = llvm.extractvalue %10[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %13 = llvm.extractvalue %10[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %14 = llvm.extractvalue %10[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %15 = llvm.extractvalue %10[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %16 = llvm.extractvalue %10[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %17 = llvm.extractvalue %10[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %18 = llvm.extractvalue %10[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %19 = llvm.extractvalue %offsets_107[0] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %20 = llvm.extractvalue %offsets_107[1] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %21 = llvm.extractvalue %offsets_107[2] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %22 = llvm.extractvalue %offsets_107[3] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %23 = llvm.extractvalue %offsets_107[4] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %24 = llvm.extractvalue %offsets_107[5] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %25 = llvm.extractvalue %offsets_107[6] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %26 = llvm.extractvalue %offsets_107[7] : !llvm.struct<(i32, i32, i32, i32, i32, i32, i32, i32)>  loc(#loc12)
    %27 = llvm.getelementptr %11[%19] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %28 = llvm.getelementptr %12[%20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %29 = llvm.getelementptr %13[%21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %30 = llvm.getelementptr %14[%22] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %31 = llvm.getelementptr %15[%23] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %32 = llvm.getelementptr %16[%24] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %33 = llvm.getelementptr %17[%25] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %34 = llvm.getelementptr %18[%26] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %35 = llvm.mlir.undef : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)> loc(#loc12)
    %36 = llvm.insertvalue %27, %35[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %37 = llvm.insertvalue %28, %36[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %38 = llvm.insertvalue %29, %37[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %39 = llvm.insertvalue %30, %38[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %40 = llvm.insertvalue %31, %39[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %41 = llvm.insertvalue %32, %40[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %42 = llvm.insertvalue %33, %41[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %43 = llvm.insertvalue %34, %42[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc12)
    %44 = llvm.extractvalue %43[0] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %45 = llvm.extractvalue %43[1] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %46 = llvm.extractvalue %43[2] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %47 = llvm.extractvalue %43[3] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %48 = llvm.extractvalue %43[4] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %49 = llvm.extractvalue %43[5] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %50 = llvm.extractvalue %43[6] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %51 = llvm.extractvalue %43[7] : !llvm.struct<(ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>, ptr<1>)>  loc(#loc13)
    %52 = llvm.extractvalue %mask_149[0] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %53 = llvm.extractvalue %mask_149[1] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %54 = llvm.extractvalue %mask_149[2] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %55 = llvm.extractvalue %mask_149[3] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %56 = llvm.extractvalue %mask_149[4] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %57 = llvm.extractvalue %mask_149[5] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %58 = llvm.extractvalue %mask_149[6] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %59 = llvm.extractvalue %mask_149[7] : !llvm.struct<(i1, i1, i1, i1, i1, i1, i1, i1)>  loc(#loc13)
    %60 = llvm.extractvalue %output_415[0] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %61 = llvm.extractvalue %output_415[1] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %62 = llvm.extractvalue %output_415[2] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %63 = llvm.extractvalue %output_415[3] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %64 = llvm.extractvalue %output_415[4] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %65 = llvm.extractvalue %output_415[5] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %66 = llvm.extractvalue %output_415[6] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %67 = llvm.extractvalue %output_415[7] : !llvm.struct<(f32, f32, f32, f32, f32, f32, f32, f32)>  loc(#loc13)
    %68 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %69 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %70 = llvm.call spir_funccc @_Z12get_local_idj(%69) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %71 = llvm.trunc %70 : i64 to i32 loc(#loc13)
    %72 = llvm.mlir.constant(127 : i32) : i32 loc(#loc13)
    %73 = llvm.and %71, %72 : i32 loc(#loc13)
    %74 = llvm.mlir.constant(32 : i32) : i32 loc(#loc13)
    %75 = llvm.urem %73, %74 : i32 loc(#loc13)
    %76 = llvm.udiv %73, %74 : i32 loc(#loc13)
    %77 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %78 = llvm.bitcast %60 : f32 to f32 loc(#loc13)
    %79 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %80 = llvm.insertelement %78, %77[%79 : i32] : vector<1xf32> loc(#loc13)
    %81 = llvm.bitcast %80 : vector<1xf32> to i32 loc(#loc13)
    %82 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %83 = llvm.bitcast %61 : f32 to f32 loc(#loc13)
    %84 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %85 = llvm.insertelement %83, %82[%84 : i32] : vector<1xf32> loc(#loc13)
    %86 = llvm.bitcast %85 : vector<1xf32> to i32 loc(#loc13)
    %87 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %88 = llvm.bitcast %62 : f32 to f32 loc(#loc13)
    %89 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %90 = llvm.insertelement %88, %87[%89 : i32] : vector<1xf32> loc(#loc13)
    %91 = llvm.bitcast %90 : vector<1xf32> to i32 loc(#loc13)
    %92 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %93 = llvm.bitcast %63 : f32 to f32 loc(#loc13)
    %94 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %95 = llvm.insertelement %93, %92[%94 : i32] : vector<1xf32> loc(#loc13)
    %96 = llvm.bitcast %95 : vector<1xf32> to i32 loc(#loc13)
    %97 = llvm.mlir.undef : vector<4xi32> loc(#loc13)
    %98 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %99 = llvm.insertelement %81, %97[%98 : i32] : vector<4xi32> loc(#loc13)
    %100 = llvm.mlir.constant(1 : i32) : i32 loc(#loc13)
    %101 = llvm.insertelement %86, %99[%100 : i32] : vector<4xi32> loc(#loc13)
    %102 = llvm.mlir.constant(2 : i32) : i32 loc(#loc13)
    %103 = llvm.insertelement %91, %101[%102 : i32] : vector<4xi32> loc(#loc13)
    %104 = llvm.mlir.constant(3 : i32) : i32 loc(#loc13)
    %105 = llvm.insertelement %96, %103[%104 : i32] : vector<4xi32> loc(#loc13)
    %106 = llvm.bitcast %44 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc13)
    llvm.cond_br %52, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %105, %106 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %107 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %108 = llvm.bitcast %64 : f32 to f32 loc(#loc13)
    %109 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %110 = llvm.insertelement %108, %107[%109 : i32] : vector<1xf32> loc(#loc13)
    %111 = llvm.bitcast %110 : vector<1xf32> to i32 loc(#loc13)
    %112 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %113 = llvm.bitcast %65 : f32 to f32 loc(#loc13)
    %114 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %115 = llvm.insertelement %113, %112[%114 : i32] : vector<1xf32> loc(#loc13)
    %116 = llvm.bitcast %115 : vector<1xf32> to i32 loc(#loc13)
    %117 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %118 = llvm.bitcast %66 : f32 to f32 loc(#loc13)
    %119 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %120 = llvm.insertelement %118, %117[%119 : i32] : vector<1xf32> loc(#loc13)
    %121 = llvm.bitcast %120 : vector<1xf32> to i32 loc(#loc13)
    %122 = llvm.mlir.undef : vector<1xf32> loc(#loc13)
    %123 = llvm.bitcast %67 : f32 to f32 loc(#loc13)
    %124 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %125 = llvm.insertelement %123, %122[%124 : i32] : vector<1xf32> loc(#loc13)
    %126 = llvm.bitcast %125 : vector<1xf32> to i32 loc(#loc13)
    %127 = llvm.mlir.undef : vector<4xi32> loc(#loc13)
    %128 = llvm.mlir.constant(0 : i32) : i32 loc(#loc13)
    %129 = llvm.insertelement %111, %127[%128 : i32] : vector<4xi32> loc(#loc13)
    %130 = llvm.mlir.constant(1 : i32) : i32 loc(#loc13)
    %131 = llvm.insertelement %116, %129[%130 : i32] : vector<4xi32> loc(#loc13)
    %132 = llvm.mlir.constant(2 : i32) : i32 loc(#loc13)
    %133 = llvm.insertelement %121, %131[%132 : i32] : vector<4xi32> loc(#loc13)
    %134 = llvm.mlir.constant(3 : i32) : i32 loc(#loc13)
    %135 = llvm.insertelement %126, %133[%134 : i32] : vector<4xi32> loc(#loc13)
    %136 = llvm.bitcast %48 : !llvm.ptr<1> to !llvm.ptr<1> loc(#loc13)
    llvm.cond_br %56, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %135, %136 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("pid"(#loc2))
#loc20 = loc("block_start"(#loc3))
#loc21 = loc("offsets"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before TritonIntelGPURewriteStackPtr (tritonintelgpu-rewrite-stack-ptr) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before ArithToLLVMConversionPass (convert-arith-to-llvm) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before Canonicalizer (canonicalize) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before CSE (cse) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before SymbolDCE (symbol-dce) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))


// -----// IR Dump Before LLVMDIScope (enable-line-info) ('builtin.module' operation) //----- //
#loc = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)
#loc8 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:16)
#loc10 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:16)
#loc15 = loc("x_ptr"(#loc))
#loc16 = loc("y_ptr"(#loc))
#loc17 = loc("output_ptr"(#loc))
#loc18 = loc("n_elements"(#loc))
#loc25 = loc("x"(#loc8))
#loc27 = loc("y"(#loc10))
module attributes {ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32, "ttg.num-ctas" = 1 : i32, "ttg.num-warps" = 4 : i32, ttg.shared = 0 : i32, ttg.target = "xpu", "ttg.threads-per-warp" = 32 : i32, ttig.min_sg_size = 16 : i32, ttig.support_2d_block_io, ttig.support_bfloat16_conversion, ttig.support_subgroup_matrix_multiply_accumulate, ttig.target_arch = "spir64"} {
  llvm.func spir_funccc @_Z12get_local_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.func spir_funccc @_Z12get_group_idj(i32) -> i64 attributes {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} loc(#loc)
  llvm.mlir.global external @global_smem() {addr_space = 3 : i32, alignment = 16 : i64} : !llvm.array<0 x i8> loc(#loc)
  llvm.func spir_kernelcc @add_kernel(%x_ptr: !llvm.ptr<1> loc("x_ptr"(#loc)), %y_ptr: !llvm.ptr<1> loc("y_ptr"(#loc)), %output_ptr: !llvm.ptr<1> loc("output_ptr"(#loc)), %n_elements: i32 loc("n_elements"(#loc)), %arg4: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0), %arg5: !llvm.ptr<1> loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":30:0)) attributes {intel_reqd_sub_group_size = 32 : i32, noinline = false, reqd_work_group_size = array<i32: 128, 1, 1>, ttg.global_scratch_memory_alignment = 1 : i32, ttg.global_scratch_memory_size = 0 : i32} {
    %0 = llvm.mlir.undef : vector<1xf32> loc(#loc1)
    %1 = llvm.mlir.constant(dense<0> : vector<4xi32>) : vector<4xi32> loc(#loc1)
    %2 = llvm.mlir.undef : vector<4xi32> loc(#loc1)
    %offsets = llvm.mlir.constant(512 : i32) : i32 loc(#loc19)
    %3 = llvm.mlir.constant(3 : i32) : i32 loc(#loc1)
    %4 = llvm.mlir.constant(1 : i32) : i32 loc(#loc1)
    %5 = llvm.mlir.constant(2 : i32) : i32 loc(#loc1)
    %offsets_0 = llvm.mlir.constant(5 : i32) : i32 loc(#loc19)
    %6 = llvm.mlir.constant(32 : i32) : i32 loc(#loc1)
    %7 = llvm.mlir.constant(127 : i32) : i32 loc(#loc1)
    %offsets_1 = llvm.mlir.constant(0 : index) : i32 loc(#loc19)
    %8 = llvm.mlir.constant(0 : i32) : i32 loc(#loc1)
    %9 = llvm.mlir.constant(1024 : i32) : i32 loc(#loc1)
    %pid = llvm.call spir_funccc @_Z12get_group_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc20)
    %pid_2 = llvm.trunc %pid : i64 to i32 loc(#loc20)
    %block_start = llvm.mul %pid_2, %9 : i32 loc(#loc21)
    %offsets_3 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc19)
    %offsets_4 = llvm.trunc %offsets_3 : i64 to i32 loc(#loc19)
    %offsets_5 = llvm.and %offsets_4, %7 : i32 loc(#loc19)
    %offsets_6 = llvm.urem %offsets_5, %6 : i32 loc(#loc19)
    %offsets_7 = llvm.udiv %offsets_5, %6 : i32 loc(#loc19)
    %offsets_8 = llvm.shl %offsets_6, %8 : i32 loc(#loc19)
    %offsets_9 = llvm.or %8, %offsets_8 : i32 loc(#loc19)
    %offsets_10 = llvm.shl %offsets_7, %offsets_0 : i32 loc(#loc19)
    %offsets_11 = llvm.or %offsets_9, %offsets_10 : i32 loc(#loc19)
    %offsets_12 = llvm.and %offsets_11, %7 : i32 loc(#loc19)
    %offsets_13 = llvm.shl %offsets_12, %5 : i32 loc(#loc19)
    %offsets_14 = llvm.or disjoint %offsets_13, %8 : i32 loc(#loc19)
    %offsets_15 = llvm.xor %8, %offsets_14 : i32 loc(#loc19)
    %offsets_16 = llvm.xor %offsets_15, %8 : i32 loc(#loc19)
    %offsets_17 = llvm.xor %offsets_15, %offsets : i32 loc(#loc19)
    %offsets_18 = llvm.add %offsets_16, %offsets_1 : i32 loc(#loc19)
    %offsets_19 = llvm.add %offsets_17, %offsets_1 : i32 loc(#loc19)
    %offsets_20 = llvm.add %block_start, %offsets_18 : i32 loc(#loc22)
    %offsets_21 = llvm.add %block_start, %offsets_19 : i32 loc(#loc22)
    %mask = llvm.icmp "slt" %offsets_20, %n_elements : i32 loc(#loc23)
    %mask_22 = llvm.icmp "slt" %offsets_21, %n_elements : i32 loc(#loc23)
    %x = llvm.getelementptr %x_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    %x_23 = llvm.getelementptr %x_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc24)
    llvm.cond_br %mask, ^bb1, ^bb2(%1 : vector<4xi32>) loc(#loc25)
  ^bb1:  // pred: ^bb0
    %x_24 = llvm.load %x {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb2(%x_24 : vector<4xi32>) loc(#loc25)
  ^bb2(%x_25: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb0, ^bb1
    %x_26 = llvm.extractelement %x_25[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_27 = llvm.bitcast %x_26 : i32 to vector<1xf32> loc(#loc25)
    %x_28 = llvm.extractelement %x_25[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_29 = llvm.bitcast %x_28 : i32 to vector<1xf32> loc(#loc25)
    %x_30 = llvm.extractelement %x_25[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_31 = llvm.bitcast %x_30 : i32 to vector<1xf32> loc(#loc25)
    %x_32 = llvm.extractelement %x_25[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_33 = llvm.bitcast %x_32 : i32 to vector<1xf32> loc(#loc25)
    %x_34 = llvm.extractelement %x_27[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_35 = llvm.extractelement %x_29[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_36 = llvm.extractelement %x_31[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_37 = llvm.extractelement %x_33[%8 : i32] : vector<1xf32> loc(#loc25)
    llvm.cond_br %mask_22, ^bb3, ^bb4(%1 : vector<4xi32>) loc(#loc25)
  ^bb3:  // pred: ^bb2
    %x_38 = llvm.load %x_23 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc25)
    llvm.br ^bb4(%x_38 : vector<4xi32>) loc(#loc25)
  ^bb4(%x_39: vector<4xi32> loc("x"(#loc8))):  // 2 preds: ^bb2, ^bb3
    %x_40 = llvm.extractelement %x_39[%8 : i32] : vector<4xi32> loc(#loc25)
    %x_41 = llvm.bitcast %x_40 : i32 to vector<1xf32> loc(#loc25)
    %x_42 = llvm.extractelement %x_39[%4 : i32] : vector<4xi32> loc(#loc25)
    %x_43 = llvm.bitcast %x_42 : i32 to vector<1xf32> loc(#loc25)
    %x_44 = llvm.extractelement %x_39[%5 : i32] : vector<4xi32> loc(#loc25)
    %x_45 = llvm.bitcast %x_44 : i32 to vector<1xf32> loc(#loc25)
    %x_46 = llvm.extractelement %x_39[%3 : i32] : vector<4xi32> loc(#loc25)
    %x_47 = llvm.bitcast %x_46 : i32 to vector<1xf32> loc(#loc25)
    %x_48 = llvm.extractelement %x_41[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_49 = llvm.extractelement %x_43[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_50 = llvm.extractelement %x_45[%8 : i32] : vector<1xf32> loc(#loc25)
    %x_51 = llvm.extractelement %x_47[%8 : i32] : vector<1xf32> loc(#loc25)
    %y = llvm.getelementptr %y_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    %y_52 = llvm.getelementptr %y_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc26)
    llvm.cond_br %mask, ^bb5, ^bb6(%1 : vector<4xi32>) loc(#loc27)
  ^bb5:  // pred: ^bb4
    %y_53 = llvm.load %y {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb6(%y_53 : vector<4xi32>) loc(#loc27)
  ^bb6(%y_54: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb4, ^bb5
    %y_55 = llvm.extractelement %y_54[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_56 = llvm.bitcast %y_55 : i32 to vector<1xf32> loc(#loc27)
    %y_57 = llvm.extractelement %y_54[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_58 = llvm.bitcast %y_57 : i32 to vector<1xf32> loc(#loc27)
    %y_59 = llvm.extractelement %y_54[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_60 = llvm.bitcast %y_59 : i32 to vector<1xf32> loc(#loc27)
    %y_61 = llvm.extractelement %y_54[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_62 = llvm.bitcast %y_61 : i32 to vector<1xf32> loc(#loc27)
    %y_63 = llvm.extractelement %y_56[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_64 = llvm.extractelement %y_58[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_65 = llvm.extractelement %y_60[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_66 = llvm.extractelement %y_62[%8 : i32] : vector<1xf32> loc(#loc27)
    llvm.cond_br %mask_22, ^bb7, ^bb8(%1 : vector<4xi32>) loc(#loc27)
  ^bb7:  // pred: ^bb6
    %y_67 = llvm.load %y_52 {alignment = 16 : i64} : !llvm.ptr<1> -> vector<4xi32> loc(#loc27)
    llvm.br ^bb8(%y_67 : vector<4xi32>) loc(#loc27)
  ^bb8(%y_68: vector<4xi32> loc("y"(#loc10))):  // 2 preds: ^bb6, ^bb7
    %y_69 = llvm.extractelement %y_68[%8 : i32] : vector<4xi32> loc(#loc27)
    %y_70 = llvm.bitcast %y_69 : i32 to vector<1xf32> loc(#loc27)
    %y_71 = llvm.extractelement %y_68[%4 : i32] : vector<4xi32> loc(#loc27)
    %y_72 = llvm.bitcast %y_71 : i32 to vector<1xf32> loc(#loc27)
    %y_73 = llvm.extractelement %y_68[%5 : i32] : vector<4xi32> loc(#loc27)
    %y_74 = llvm.bitcast %y_73 : i32 to vector<1xf32> loc(#loc27)
    %y_75 = llvm.extractelement %y_68[%3 : i32] : vector<4xi32> loc(#loc27)
    %y_76 = llvm.bitcast %y_75 : i32 to vector<1xf32> loc(#loc27)
    %y_77 = llvm.extractelement %y_70[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_78 = llvm.extractelement %y_72[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_79 = llvm.extractelement %y_74[%8 : i32] : vector<1xf32> loc(#loc27)
    %y_80 = llvm.extractelement %y_76[%8 : i32] : vector<1xf32> loc(#loc27)
    %output = llvm.fadd %x_34, %y_63 : f32 loc(#loc28)
    %output_81 = llvm.fadd %x_35, %y_64 : f32 loc(#loc28)
    %output_82 = llvm.fadd %x_36, %y_65 : f32 loc(#loc28)
    %output_83 = llvm.fadd %x_37, %y_66 : f32 loc(#loc28)
    %output_84 = llvm.fadd %x_48, %y_77 : f32 loc(#loc28)
    %output_85 = llvm.fadd %x_49, %y_78 : f32 loc(#loc28)
    %output_86 = llvm.fadd %x_50, %y_79 : f32 loc(#loc28)
    %output_87 = llvm.fadd %x_51, %y_80 : f32 loc(#loc28)
    %10 = llvm.getelementptr %output_ptr[%offsets_20] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %11 = llvm.getelementptr %output_ptr[%offsets_21] : (!llvm.ptr<1>, i32) -> !llvm.ptr<1>, f32 loc(#loc12)
    %12 = llvm.call spir_funccc @_Z12get_local_idj(%8) {memory_effects = #llvm.memory_effects<other = none, argMem = none, inaccessibleMem = none, errnoMem = none, targetMem0 = none, targetMem1 = none>, no_unwind, will_return} : (i32) -> i64 loc(#loc13)
    %13 = llvm.insertelement %output, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %14 = llvm.bitcast %13 : vector<1xf32> to i32 loc(#loc13)
    %15 = llvm.insertelement %output_81, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %16 = llvm.bitcast %15 : vector<1xf32> to i32 loc(#loc13)
    %17 = llvm.insertelement %output_82, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %18 = llvm.bitcast %17 : vector<1xf32> to i32 loc(#loc13)
    %19 = llvm.insertelement %output_83, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %20 = llvm.bitcast %19 : vector<1xf32> to i32 loc(#loc13)
    %21 = llvm.insertelement %14, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %22 = llvm.insertelement %16, %21[%4 : i32] : vector<4xi32> loc(#loc13)
    %23 = llvm.insertelement %18, %22[%5 : i32] : vector<4xi32> loc(#loc13)
    %24 = llvm.insertelement %20, %23[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask, ^bb9, ^bb10 loc(#loc13)
  ^bb9:  // pred: ^bb8
    llvm.store %24, %10 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb10 loc(#loc13)
  ^bb10:  // 2 preds: ^bb8, ^bb9
    %25 = llvm.insertelement %output_84, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %26 = llvm.bitcast %25 : vector<1xf32> to i32 loc(#loc13)
    %27 = llvm.insertelement %output_85, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %28 = llvm.bitcast %27 : vector<1xf32> to i32 loc(#loc13)
    %29 = llvm.insertelement %output_86, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %30 = llvm.bitcast %29 : vector<1xf32> to i32 loc(#loc13)
    %31 = llvm.insertelement %output_87, %0[%8 : i32] : vector<1xf32> loc(#loc13)
    %32 = llvm.bitcast %31 : vector<1xf32> to i32 loc(#loc13)
    %33 = llvm.insertelement %26, %2[%8 : i32] : vector<4xi32> loc(#loc13)
    %34 = llvm.insertelement %28, %33[%4 : i32] : vector<4xi32> loc(#loc13)
    %35 = llvm.insertelement %30, %34[%5 : i32] : vector<4xi32> loc(#loc13)
    %36 = llvm.insertelement %32, %35[%3 : i32] : vector<4xi32> loc(#loc13)
    llvm.cond_br %mask_22, ^bb11, ^bb12 loc(#loc13)
  ^bb11:  // pred: ^bb10
    llvm.store %36, %11 {alignment = 16 : i64} : vector<4xi32>, !llvm.ptr<1> loc(#loc13)
    llvm.br ^bb12 loc(#loc13)
  ^bb12:  // 2 preds: ^bb10, ^bb11
    llvm.return loc(#loc14)
  } loc(#loc)
} loc(#loc)
#loc1 = loc(unknown)
#loc2 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:41)
#loc3 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":39:24)
#loc4 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":44:24)
#loc5 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":45:28)
#loc6 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":47:21)
#loc7 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":50:24)
#loc9 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":51:24)
#loc11 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":52:17)
#loc12 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:26)
#loc13 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:35)
#loc14 = loc("/home/jovyan/intel-xpu-backend-for-triton/python/tutorials/01-vector-add.py":54:4)
#loc19 = loc("offsets"(#loc2))
#loc20 = loc("pid"(#loc3))
#loc21 = loc("block_start"(#loc4))
#loc22 = loc("offsets"(#loc5))
#loc23 = loc("mask"(#loc6))
#loc24 = loc("x"(#loc7))
#loc26 = loc("y"(#loc9))
#loc28 = loc("output"(#loc11))
